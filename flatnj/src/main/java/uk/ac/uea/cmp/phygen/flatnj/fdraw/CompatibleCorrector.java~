package FDraw;


import java.util.*;

/*
 * To change this template, choose Tools | Templates and open the template in
 * the editor.
 */
/**
 *
 * @author balvociute
 */
public class CompatibleCorrector
{

    AngleCalculator angleCalculator;
    private double balloonAngle = Math.PI * 0.99;

    public CompatibleCorrector(AngleCalculator ac)
    {
        this.angleCalculator = ac;
    }

    public double correctAnglesForTrivial(LinkedList<Edge> edges, LinkedList<Vertex> vertices)
    {
        Edge split = edges.getFirst();

        Set<Edge> topEdges = Collector.getAllEdges(edges, true);
        Set<Edge> bottomEdges = Collector.getAllEdges(edges, false);

        double deltaAlpha;

        deltaAlpha = angleCalculator.computeForCompatible(edges);
        if (!Translocator.noCollisions(edges, topEdges, bottomEdges, deltaAlpha))
        {
            //deltaAlpha = angleCalculator.computeMiddleAngleForTrivial(split);
        }

        if (Translocator.noCollisions(edges, topEdges, bottomEdges, deltaAlpha))
        {
            Translocator.changeCoordinates(edges, deltaAlpha);
            for (int i = 0; i < vertices.size(); i++)
            {
                vertices.get(i).visited = false;
                LinkedList<Edge> vEd = vertices.get(i).elist;
                for (int k = 0; k < vEd.size(); k++)
                {
                    vEd.get(k).visited = false;
                }
            }
            return deltaAlpha;
        }
        return 0.0;
    }

    public double correctAngles(LinkedList<Edge> edges, LinkedList<Vertex> vertices)
    {
        Edge split = edges.getFirst();

        Vertex bottom = split.bot;
        Vertex top = split.top;

        Vertex v = bottom;
        Vertex w = top;


        Set<Edge> topEdges = Collector.getAllEdges(edges, true);
        Set<Edge> bottomEdges = Collector.getAllEdges(edges, false);

        double deltaAlpha = angleCalculator.computeForCompatible(edges);

        if (Translocator.noCollisions(edges, topEdges, bottomEdges, deltaAlpha))
        {
            Translocator.changeCoordinates(edges, deltaAlpha);
            for (int i = 0; i < vertices.size(); i++)
            {
                vertices.get(i).visited = false;
                LinkedList<Edge> vEd = vertices.get(i).elist;
                for (int k = 0; k < vEd.size(); k++)
                {
                    vEd.get(k).visited = false;
                }
            }
            return deltaAlpha;
        }
        return 0.0;
    }

    public Vertex addEdgesforExternalTrivialSplits(Vertex v, Perm_sequence pseq)
    {
        Double minW = null;

        LinkedList<Edge> allEdges = DrawFlat.collect_edges(v.elist.getFirst());
        for (int i = 0; i < allEdges.size(); i++)
        {
            minW = ((minW == null || minW > allEdges.get(i).length()) ? allEdges.get(i).length() : minW);
        }
        minW /= 10;

        Set<Edge> externalEdges = new HashSet<>();
        Collector.getExternalEdges(externalEdges, v.elist.getFirst(), v, v.elist.getFirst());

        double[] trivial = pseq.trivial;
        if (trivial != null)
        {
            Set<Vertex> externalVertices = Collector.getExternalVertices(v.elist.getFirst(), v.elist.getFirst().top, v.elist.getFirst());
            externalVertices.addAll(Collector.getExternalVertices(v.elist.getFirst(), v.elist.getFirst().bot, v.elist.getFirst()));
            Iterator<Vertex> it = externalVertices.iterator();
            while (it.hasNext())
            {
                Vertex vertex = it.next();
                int partitions = 0;
                for (int i = 0; i < vertex.taxa.size(); i++)
                {
                    int taxaNr = vertex.taxa.get(i);
                    double w = trivial[taxaNr];
                    if (w > 0)
                    {
                        partitions++;
                    }
                }
                if (partitions > 0)
                {
                    Edge left;
                    Edge right;

                }
            }
        }
        return v;
    }

    public void addInnerTrivial(Vertex V, Perm_sequence ps, boolean color)
    {
        LinkedList<LinkedList<Edge>> balloons = Collector.collectBallons(balloonAngle, V);

        LinkedList<Vertex>[] verticesInBalloons = Collector.assignVerticesToBalloons(balloons, V);
        
        LinkedList<Edge> trivial = new LinkedList<>();

        int lastSplit = getHighestNexusId(balloons.getFirst().getFirst());
        
        for (int i = 0; i < balloons.size(); i++)
        {
            LinkedList<Edge> edges = balloons.get(i);
            //Vertex c = computeCenterPoint(edges);

            LinkedList<Edge> edgesBefore = (i == 0) ? balloons.getLast() : balloons.get(i - 1);
            LinkedList<Edge> edgesAfter = (i == balloons.size() - 1) ? balloons.getFirst() : balloons.get(i + 1);
            Vertex c = computeCenterPoint(edgesBefore, edges, edgesAfter);

            boolean inside = pointInsideNetwork(c, Collector.collectAllExternalEdges(V, false));
            if (!inside)
            {
                c = computeCenterPoint(edges);
            }

            
            c.setSize(10);
            int[] white = new int[3];
            white[0] = 255;
            white[1] = 255;
            white[2] = 255;

            int[] red = new int[3];
            red[0] = 255;
            LinkedList<Vertex> vertices = verticesInBalloons[i];

            if (vertices.size() > 0)
            {
//                Vertex some = vertices.getFirst();
//                Edge newE = new Edge(c, some, lastSplit, 0);
//                newE.setColor(red);
//                some.elist = new LinkedList<>();
//                some.elist.add(newE);
//                c.elist.add(newE);
//                vertices.add(c);

                LinkedList<Vertex> newVertices = new LinkedList<>();
                LinkedList<Vertex> oldVertices = new LinkedList<>();

                for (int j = 0; j < vertices.size(); j++)
                {
                    Vertex v = vertices.get(j);
                    Vertex w;
                    Edge e;

                    if (v.elist.size() > 1)
                    {
                        LinkedList<Integer> taxa = v.taxa;
                        int nTaxa = taxa.size();

                        double anglePlus = 0.0; //is used in order to avoid edge overlaping
                        for(int t = taxa.size()-1; t >= 0; t--)
                        {
                            Integer taxon = taxa.get(t);
                            double length = ps.trivial[taxon];

                            if (length > 0)
                            {
                                taxa.remove(taxon);

                                double x;
                                double y;

                                w = new Vertex(v.x, v.y);
                                e = new Edge(v, w, lastSplit, 0);
                                v.elist.add(e);
                                w.elist.add(e);
                                w.taxa = new LinkedList<>();
                                w.taxa.add(taxon);
                                oldVertices.add(v);
                                newVertices.add(w);
                                
                                double sinAlpha = getSinusAlpha(v, c);
                                double alpha = Math.asin(sinAlpha);
                                alpha += anglePlus;
                                anglePlus += 0.1;
                                sinAlpha = Math.sin(alpha);
                                        
                                        
                                if (v.y >= c.y)
                                {
                                    y = v.y + length * sinAlpha;
                                }
                                else
                                {
                                    y = v.y - length * sinAlpha;
                                }

                                double cosAlpha = Math.cos(alpha);

                                if (w.x >= c.x)
                                {
                                    x = v.x + length * cosAlpha;
                                }
                                else
                                {
                                    x = v.x - length * cosAlpha;
                                }

                                w.x = x;
                                w.y = y;
                            }
                        }
                    }

                }
                for (int j = 0; j < oldVertices.size(); j++)
                {
                    vertices.remove(oldVertices.get(j));
                }
                for (int q = 0; q < newVertices.size(); q++)
                {
                    vertices.add(newVertices.get(q));
                }
            }
        }
        if (color)
        {
            colorBalloons(balloons, verticesInBalloons);
        }
    }

    private void colorBalloons(LinkedList<LinkedList<Edge>> balloons, LinkedList<Vertex>[] verticesInBalloons)
    {
        Random rand = new Random();
        for (int i = 0; i < balloons.size(); i++)
        {
            int[] colors = new int[3];
            for (int j = 0; j < colors.length; j++)
            {
                colors[j] = (int) (rand.nextFloat() * 200);
            }
            LinkedList<Edge> currentBalloon = balloons.get(i);
            for (int j = 0; j < currentBalloon.size(); j++)
            {
                currentBalloon.get(j).setColor(colors);
            }
            for (int j = 0; j < verticesInBalloons[i].size(); j++)
            {
                Vertex w = verticesInBalloons[i].get(j);
                w.setColor(colors);
                if (w.height == 2)
                {
                    w.setSize(5);
                }
            }
        }
    }

    private int getHighestNexusId(Edge e)
    {
        LinkedList<Edge> edges = DrawFlat.collect_edges(e);
        int max = -1;
        for (int i = 0; i < edges.size(); i++)
        {
            Edge current = edges.get(i);
            max = (max < current.idxsplit) ? current.idxsplit : max;
        }
        return max;
    }

    public void correctCompatible(LinkedList<Edge> allEdges, Vertex V)
    {

        LinkedList<LinkedList<Edge>> balloons = Collector.collectBallons(balloonAngle, V);
        LinkedList<Vertex>[] verticesInBalloons = Collector.assignVerticesToBalloons(balloons, V);

        for (int i = 0; i < balloons.size(); i++)
        {
            LinkedList<Edge> edges = balloons.get(i);
            //Vertex c = computeCenterPoint(edges);

            LinkedList<Edge> edgesBefore = (i == 0) ? balloons.getLast() : balloons.get(i - 1);
            LinkedList<Edge> edgesAfter = (i == balloons.size() - 1) ? balloons.getFirst() : balloons.get(i + 1);
            Vertex c = computeCenterPoint(edgesBefore, edges, edgesAfter);

            LinkedList<Vertex> vertices = verticesInBalloons[i];

            for (int j = 0; j < vertices.size(); j++)
            {
                Vertex w = vertices.get(j);
                if (w.elist.size() == 1)
                {
                    Edge e = w.elist.getFirst();

                    double x;
                    double y;
                    Vertex v = (e.top == w) ? e.bot : e.top;
                    double sinAlpha = getSinusAlpha(v, c);
                    
                    
                    double length = e.length();
                    if (v.y >= c.y)
                    {
                        y = v.y + length * sinAlpha;
                    }
                    else
                    {
                        y = v.y - length * sinAlpha;
                    }

                    double cosAlpha = getCosinusAlpha(v, c);

                    if (v.x >= c.x)
                    {
                        x = v.x + length * cosAlpha;
                    }
                    else
                    {
                        x = v.x - length * cosAlpha;
                    }

                    if (!Translocator.twoLinesCrosses(v.x, v.y, x, y, new HashSet<>(allEdges)) && !Translocator.twoLinesCrosses(w.x, w.y, x, y, new HashSet<>(allEdges)))
                    {
                        w.x = x;
                        w.y = y;
                    }
                }
            }
        }
    }

    private double getSinusAlpha(Vertex v, Vertex c)
    {
        double sinAlpha = Math.abs(v.y - c.y) / Math.sqrt((v.x - c.x) * (v.x - c.x) + (v.y - c.y) * (v.y - c.y));
        return sinAlpha;
    }

    private double getCosinusAlpha(Vertex v, Vertex c)
    {
        double sinAlpha = Math.abs(v.x - c.x) / Math.sqrt((v.x - c.x) * (v.x - c.x) + (v.y - c.y) * (v.y - c.y));
        return sinAlpha;
    }

    private Vertex computeCenterPoint(LinkedList<Edge> edges)
    {
        Vertex v1;
        Vertex v2;
        Edge first = edges.getFirst();
        Edge last = edges.getLast();
        if (first == last)
        {
            v1 = first.bot;
            v2 = first.top;
        }
        else
        {
            Edge second = edges.get(1);
            Edge penult = edges.get(edges.indexOf(last) - 1);
            v1 = (first.bot == second.bot || first.bot == second.top) ? first.top : first.bot;
            v2 = (last.bot == penult.bot || last.bot == penult.top) ? last.top : last.bot;
        }
        double x = 0.5 * (v1.x + v2.x);
        double y = 0.5 * (v1.y + v2.y);
        return new Vertex(x, y);
    }

    private Vertex computeCenterPoint(LinkedList<Edge> edgesBefore, LinkedList<Edge> edges, LinkedList<Edge> edgesAfter)
    {
        Line first = getMiddleLine(edgesBefore, edges);
        Line last = getMiddleLine(edges, edgesAfter);
        double x = (first.b - last.b) / (last.a - first.a);
        double y = first.a * x + first.b;
        return new Vertex(x, y);
    }

    private Line getMiddleLine(LinkedList<Edge> edges1, LinkedList<Edge> edges2)
    {
        Edge beforeLast = edges1.getLast();
        Edge fist = edges2.getFirst();

        Set<Vertex> vertices1 = getVerticesFromEdges(edges1);
        Set<Vertex> vertices2 = getVerticesFromEdges(edges2);

        Vertex v = (beforeLast.bot == fist.bot || beforeLast.bot == fist.top) ? beforeLast.bot : beforeLast.top;
        Vertex w1 = (beforeLast.bot == v) ? beforeLast.top : beforeLast.bot;
        Vertex w2 = (fist.bot == v) ? fist.top : fist.bot;

        vertices1.remove(v);
        vertices2.remove(v);

        AngleCalculatorSimple angleCalculatorSimple = new AngleCalculatorSimple();
        Vertex striker = angleCalculatorSimple.findStrikerOnTheRight(v, w1, vertices1);
        Vertex defender = angleCalculatorSimple.findDefenderOnTheRight(v, w2, vertices2);

        double alpha = AngleCalculatorSimple.getClockwiseAngle(striker, v, defender) * 0.5;
        double xt = w2.x - v.x;
        double yt = w2.y - v.y;

        double x = xt * Math.cos(alpha) - yt * Math.sin(alpha) + v.x;
        double y = xt * Math.sin(alpha) + yt * Math.cos(alpha) + v.y;

        return new Line(v, new Vertex(x, y));

    }

    private Set<Vertex> getVerticesFromEdges(LinkedList<Edge> edges)
    {
        Set<Vertex> vertices = new HashSet<>();
        for (int i = 0; i < edges.size(); i++)
        {
            vertices.add(edges.get(i).bot);
            vertices.add(edges.get(i).top);
        }
        return vertices;
    }

    public void correctAllCompatible(TreeSet[] splitedges, LinkedList<Vertex> vertices)
    {
        for (int i = 0; i < splitedges.length; i++)
        {
            if (splitedges[i].size() == 1)
            {
                Edge e = (Edge) splitedges[i].first();
                LinkedList<Edge> edges = new LinkedList<>();
                edges.add(e);
                double moved = 0.0;
                if (e.top.elist.size() == 1 || e.bot.elist.size() == 1)
                {
                    moved = correctAnglesForTrivial(edges, vertices);
                }
                if (moved == 0)
                {
                    correctAngles(edges, vertices);
                }
            }
        }
    }

    private boolean pointInsideNetwork(Vertex c, LinkedList<Edge> external)
    {
        int crossingsWithBorders = castRay(c, external);
        if (crossingsWithBorders % 2 == 0)
        {
            return false;
        }
        return true;
    }

    private int castRay(Vertex c, LinkedList<Edge> edges)
    {
        Line ray = new Line(c, new Vertex(c.x + 1, c.y + 1));
        int crossings = 0;
        Iterator<Edge> edgeIterator = edges.iterator();
        while (edgeIterator.hasNext())
        {
            Edge e = edgeIterator.next();
            Line eLine = new Line(e);
            Vertex intP = intersection(ray, eLine);
            if (Math.signum(intP.x - e.top.x) != Math.signum(intP.x - e.bot.x))
            {
                crossings++;
            }
        }
        return crossings;
    }

    private Vertex intersection(Line l1, Line l2)
    {
        double x = (l2.b - l1.b) / (l1.a - l2.a);
        double y = l1.a * x + l1.b;
        return new Vertex(x, y);
    }

    public void moveTrivial(Vertex V, int iterations)
    {
        LinkedList<Edge> trivial = Collector.collectAllTrivial(V);
        double angle = Math.PI * 0.99;
        LinkedList<Edge> inner = DrawFlat.collect_edges(V.elist.element());
                      
        for (int i = 0; i < trivial.size(); i++)
        {
            inner.remove(trivial.get(i));
        }
        
        
        LinkedList<Edge> external = Collector.collectAllExternalEdges(V, false);
        for (int i = 0; i < external.size(); i++)
        {
            inner.remove(external.get(i));
        }
        
        List<Double> angl = new LinkedList<>();
        while(angle > 0.001)
        {
            angl.add(angle);
            angle *= 0.9;
        }
        double[] angles = new double[angl.size()];
        for (int i = 0; i < angles.length; i++)
        {
            angles[i] = angl.get(i);
        }
        
        char sign;
        int corrected = 1;
        while (corrected != 0 && iterations > 0)
        {
            iterations--;
            corrected = iterateMovement(angles, trivial, inner, external, true);
            //corrected = iterateMovement(angles, trivial, inner, external, false);

        }
        System.err.println();
    }

    private int iterateMovement(double[] angles, LinkedList<Edge> trivial, LinkedList<Edge> inner, LinkedList<Edge> external, boolean startToEnd)
    {
        int corrected = 0;
        char sign;
        for (int j = 0; j < angles.length; j++)
        {
            sign = '.';
            double angle = angles[j];
            double alphaPlus = angle;
            double alphaMinus = 2 * Math.PI - angle;
            if (startToEnd)
            {
                for (int i = 0; i < trivial.size(); i++)
                {
                    double currentCorrected = tryToMove(trivial, i, inner, external, alphaPlus, alphaMinus);
                    corrected += currentCorrected;
                    sign = (currentCorrected > 0) ? '*' : sign;
                }
            }
            else
            {
                for (int i = trivial.size() - 1; i >= 0; i--)
                {
                    double currentCorrected = tryToMove(trivial, i, inner, external, alphaPlus, alphaMinus);
                    corrected += currentCorrected;
                    sign = (currentCorrected > 0) ? '*' : sign;
                }
            }


            System.err.print(sign);
            if (j == angles.length - 1)
            {
                System.err.println();
            }
        }
        return corrected;
    }

    private int tryToMove(LinkedList<Edge> trivial, int i, LinkedList<Edge> inner, LinkedList<Edge> external, double alphaPlus, double alphaMinus)
    {
        int corrected = 0;
        Edge e = trivial.get(i);
        if (e.length() > 0)
        {
            Vertex v = (e.bot.elist.size() == 1) ? e.top : e.bot;
            Vertex w = (e.bot == v) ? e.top : e.bot;

            Score eScore = getScore(v.x, v.y, w.x, w.y, trivial, e, inner, external);

            double xt = w.x - v.x;
            double yt = w.y - v.y;

            double xP = xt * Math.cos(alphaPlus) - yt * Math.sin(alphaPlus) + v.x;
            double yP = xt * Math.sin(alphaPlus) + yt * Math.cos(alphaPlus) + v.y;

            Score eScorePlus = getScore(v.x, v.y, xP, yP, trivial, e, inner, external);

            double xM = xt * Math.cos(alphaMinus) - yt * Math.sin(alphaMinus) + v.x;
            double yM = xt * Math.sin(alphaMinus) + yt * Math.cos(alphaMinus) + v.y;

            Score eScoreMinus = getScore(v.x, v.y, xM, yM, trivial, e, inner, external);

            if (pointNotInTheSet(v, external))
            {
                if (eScoreMinus.betterInternal(eScorePlus) && eScoreMinus.betterInternal(eScore))
                {
                    w.x = xM;
                    w.y = yM;
                    corrected++;
                }
                else if (eScorePlus.betterInternal(eScoreMinus) && eScorePlus.betterInternal(eScore))
                {
                    w.x = xP;
                    w.y = yP;
                    corrected++;
                }
            }
            else
            {
                if (eScoreMinus.betterExternal(eScorePlus) && eScoreMinus.betterExternal(eScore))
                {
                    w.x = xM;
                    w.y = yM;
                    corrected++;
                }
                else if (eScorePlus.betterExternal(eScoreMinus) && eScorePlus.betterExternal(eScore))
                {
                    w.x = xP;
                    w.y = yP;
                    corrected++;
                }
            }
        }
        return corrected;

    }

    private Score getScore(double x, double y, double x1, double y1, LinkedList<Edge> trivial, Edge e, LinkedList<Edge> internal, LinkedList<Edge> external)
    {
        Score score = new Score();

        double punishmentNonTrivial = 1;
        double punishmentTrivial = 1;
        double punishmentSame = 1;
        double punishmentInside = 1;

        double intersectionOutsideScore = 0.0;
        double intersectionInsideScore = 0.0;
        double intersectionTrivialScore = 0.0;
        double distanceScore = 0.0;
        double sameScore = 0.0;
        double insideScore = 0.0;
        double angleScore = 0.0;
        double pendantScore = 0.0;

        if (!pointNotInTheSet(new Vertex(x, y), external))
        {
            intersectionTrivialScore += sumUpIntersections(x, y, x1, y1, punishmentTrivial, trivial);
            intersectionInsideScore += sumUpIntersections(x, y, x1, y1, punishmentTrivial, internal);
            intersectionOutsideScore += sumUpIntersections(x, y, x1, y1, punishmentSame, external);
        }
        else
        {
            if (pointInsideNetwork(new Vertex(x1, y1), external))
            {
                insideScore += punishmentInside;
            }
            else
            {
                pendantScore += getPendantScore(x, y, x1, y1, e, external);
            }
            intersectionTrivialScore += sumUpIntersections(x, y, x1, y1, punishmentTrivial, trivial);
            intersectionInsideScore += sumUpIntersections(x, y, x1, y1, punishmentNonTrivial, internal);
            int externalCrossed = (int) sumUpIntersections(x, y, x1, y1, 1, external);
            if (externalCrossed > 1)
            {
                intersectionOutsideScore += (externalCrossed * punishmentTrivial);
            }
            else
            {
                //intersectionOutsideScore -= (externalCrossed * punishmentTrivial);
            }
            distanceScore += sumUpDistances(e, x1, y1, internal);
        }
        //distanceScore += sumUpDistances(e, x1, y1, internal);
        distanceScore += sumUpDistances(e, x1, y1, trivial);
        distanceScore += sumUpDistances(e, x1, y1, external);

        angleScore += scoreAngles(e, x, y, x1, y1);

        score.insideScore = insideScore;
        score.intTrScore = intersectionTrivialScore;
        score.intInScore = intersectionInsideScore;
        score.intOutScore = intersectionOutsideScore;
        score.distScore = distanceScore;
        score.anglScore = angleScore;
        score.pendantScore = pendantScore;
        
        return score;
    }
    
    private double getPendantScore(double x, double y, double x1, double y1,Edge ee, LinkedList<Edge> external)
    {
        double score = 0.0;
        for (int i = 0; i < external.size(); i++)
        {
            Edge e = external.get(i);
            Vertex c = Translocator.getIntersectionPoint(x, y, x1, y1, e.bot.x, e.bot.y, e.top.x, e.top.y);
            if(c != null)
            {
                score = (ee.length() - AngleCalculatorSimple.distance(new Vertex(x1, y1), c)) / ee.length();
            }
        }
        return score;
    }

    private double scoreAngles(Edge e, double x, double y, double x1, double y1)
    {
        Double score = null;
        int atAll = 0;
        double threshold = Math.PI / 2.0;
        Vertex v = (e.bot.x == x && e.bot.y == y) ? e.bot : e.top;
        Vertex w = new Vertex(x1, y1);
        LinkedList<Edge> incident = v.elist;
        for (int i = 0; i < incident.size(); i++)
        {
            Edge ee = incident.get(i);
            if (e != ee)
            {
                Vertex w2 = (ee.bot == v) ? ee.top : ee.bot;
                double angle = angleCalculator.getAngle(w, v, w2);
                
                score = (score == null || score > angle) ? angle : score;
                
//                if (angle < threshold)
//                {
//                    double current = (threshold - angle) / threshold;
//                    score += current * current;
//                    atAll++;
//                }
            }
        }
        return score ;
    }

    private class Score
    {
        double distScore;
        double anglScore;
        double insideScore;
        double pendantScore;
        private double intTrScore;
        private double intInScore;
        double intOutScore;

        private boolean betterExternal(Score s)
        {
            double intBoolean = (intInScore + intOutScore == 0) ? 0 : 1; 
            double intBoolean2 = (s.intInScore + s.intOutScore == 0) ? 0 : 1; 
            
            if(insideScore < s.insideScore)
            {
                return true;
            }
            else if(insideScore == s.insideScore)
            {
                if(intTrScore < s.intTrScore)
                {
                    return true;
                }
                else if(intTrScore == s.intTrScore)
                {
                    if(intBoolean < intBoolean2)
                    {
                        return true;
                    }
                    else if(intBoolean == intBoolean2)
                    {
                        if(distScore < s.distScore * 1.05 && anglScore > 0.25 && anglScore > s.anglScore * 0.95)
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        private boolean betterInternal(Score s)
        {
            double intBoolean = (intInScore + intOutScore == 0) ? 0 : 1; 
            double intBoolean2 = (s.intInScore + s.intOutScore == 0) ? 0 : 1; 
            
            if(insideScore < s.insideScore)
            {
                return true;
            }
            else if(insideScore == s.insideScore && intOutScore == 0)
            {
                if(intTrScore < s.intTrScore)
                {
                    return true;
                }
                else if(intTrScore == s.intTrScore)
                {
                    if(distScore < s.distScore * 1.05 && anglScore > 0.25 && anglScore > s.anglScore * 0.95)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        private boolean equal(Score s)
        {
            if(insideScore == s.insideScore && intTrScore == s.intTrScore &&
                    (intInScore + intOutScore) == (s.intInScore + s.intOutScore)
                    && distScore == s.distScore)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        private void printScore()
        {
            System.out.println("SCORE:");
            System.out.println("pendant  " + pendantScore);
            System.out.println("distance " + distScore);
            System.out.println("inside   " + insideScore);
            System.out.println("int in   " + intInScore);
            System.out.println("int out  " + intOutScore);
            System.out.println("int triv " + intTrScore);
        }
    }

    private double sumUpIntersections(double x, double y, double x1, double y1, double punishment, LinkedList<Edge> edges)
    {
        double score = 0.0;
        for (int i = 0; i < edges.size(); i++)
        {
            Edge ee = edges.get(i);
            if (Translocator.cross(x, y, x1, y1, ee.bot.x, ee.bot.y, ee.top.x, ee.top.y))
            {
                score += punishment;
            }
        }
        return score;
    }

    private double sumUpDistances(Edge e, double x1, double y1, LinkedList<Edge> edges)
    {
        double score = 0.0;
        double length = e.length() * 0.75;
        Iterator<Edge> iterator = (new HashSet<>(edges)).iterator();
        while (iterator.hasNext())
        {
            Edge ee = iterator.next();

            double distance = Collector.getDistanceToEgde(new Vertex(x1, y1), ee);

            if(distance <= length)
            {
                double current = (length - distance) / length;
//                int cur = (int) (current * 10);
//                current = ((double) cur)/10.0;
                score += current * current * current;
            }
        }
        return score;
    }

    private boolean pointNotInTheSet(Vertex vertex, LinkedList<Edge> edges)
    {
        for (int i = 0; i < edges.size(); i++)
        {
            Edge e = edges.get(i);
            if ((e.bot.x == vertex.x && e.bot.y == vertex.y) || (e.top.x == vertex.x && e.top.y == vertex.y))
            {
                return false;
            }
        }
        return true;
    }

    private class Line
    {

        double a;
        double b;

        private Line(Vertex v, Vertex w)
        {
            setAB(v, w);
        }

        private Line(Edge e)
        {
            setAB(e.bot, e.top);
        }

        private Line(double x1, double y1, double x2, double y2)
        {
            a = (y1 - y2) / (x1 - x2);
            b = y1 - a * x1;
        }

        private void setAB(Vertex v, Vertex w)
        {
            a = (v.y - w.y) / (v.x - w.x);
            b = v.y - a * v.x;
        }

        public boolean equals(Line l2)
        {
            if (this.a == l2.a && this.b == l2.b)
            {
                return true;
            }
            return false;
        }
    }
}
